import React, { useState, useEffect, useRef } from 'react';
import { View, TouchableOpacity, Text, StyleSheet, Modal, ScrollView, Alert, TextInput, FlatList, SafeAreaView, ActivityIndicator, Animated, Easing, Dimensions, StatusBar, Image, Platform, Pressable, LayoutAnimation, UIManager } from 'react-native';
import { Audio } from 'expo-av';
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system/legacy';
import Constants from 'expo-constants';
import { Ionicons, MaterialCommunityIcons, MaterialIcons, FontAwesome5 } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Helper to format date
const formatDate = (isoString) => {
  if (!isoString) return '';
  const date = new Date(isoString);
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }).replace(',', '');
};

// Waveform Bar Component
const WaveBar = ({ level, index, isRecording }) => {
  const animatedHeight = useRef(new Animated.Value(5)).current;

  useEffect(() => {
    // Idle state: height 5 (dot). Active state: height based on level.
    const targetHeight = isRecording ? Math.max(5, level * 50) : 5;

    Animated.timing(animatedHeight, {
      toValue: targetHeight,
      duration: 100,
      useNativeDriver: false,
    }).start();
  }, [level, isRecording]);

  return (
    <Animated.View
      style={{
        width: 5,
        height: animatedHeight,
        backgroundColor: '#1C1C1E',
        marginHorizontal: 3,
        borderRadius: 2.5,
      }}
    />
  );
};

// --- Added for Screen 1 Replication ---
if (Platform.OS === 'android') {
  if (UIManager.setLayoutAnimationEnabledExperimental) {
    UIManager.setLayoutAnimationEnabledExperimental(true);
  }
}

const COLORS = {
  background: '#f5f5f5',
  white: '#ffffff',
  searchBg: '#e4e4e4',
  filterBorder: '#e6e6e6',
  activeFilter: '#212121',
  textPrimary: '#000000',
  textSecondary: '#868686',
  border: '#eaeaea',
  shadow: 'rgba(218, 218, 218, 0.25)',
  fab: '#0e0e0e',
};

// Cozy Scale Button Wrapper
const ScalePress = ({ children, onPress, style, activeScale = 0.95 }) => {
  const scaleAnim = useRef(new Animated.Value(1)).current;

  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: activeScale,
      useNativeDriver: true,
      speed: 20,
      bounciness: 10,
    }).start();
  };

  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      useNativeDriver: true,
      speed: 20,
      bounciness: 10,
    }).start();
  };

  return (
    <Pressable onPress={onPress} onPressIn={handlePressIn} onPressOut={handlePressOut}>
      <Animated.View style={[style, { transform: [{ scale: scaleAnim }] }]}>
        {children}
      </Animated.View>
    </Pressable>
  );
};

export default function App() {
  // Screen State: 'home', 'recording', 'details'
  const [currentScreen, setCurrentScreen] = useState('home');

  // Data State
  const [savedLectures, setSavedLectures] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');

  // Active Lecture State
  const [currentLectureId, setCurrentLectureId] = useState(null);
  const [recording, setRecording] = useState(null);
  const [isRecording, setIsRecording] = useState(false);
  const [audioUri, setAudioUri] = useState(null);
  const [player, setPlayer] = useState(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [playbackPosition, setPlaybackPosition] = useState(0);
  const [playbackDuration, setPlaybackDuration] = useState(1);
  const [transcribedText, setTranscribedText] = useState('');
  const [transcriptSegments, setTranscriptSegments] = useState([]);
  const [summary, setSummary] = useState('');
  const [flashcards, setFlashcards] = useState([]);
  const [aiPrompt, setAiPrompt] = useState('');

  // UI State
  const [isProcessing, setIsProcessing] = useState(false);
  const [processingStatus, setProcessingStatus] = useState('');
  const [activeTab, setActiveTab] = useState('transcript');
  const [materialsSubTab, setMaterialsSubTab] = useState('flashcards');
  const [currentFlashcardIndex, setCurrentFlashcardIndex] = useState(0);
  const [showFlashcardAnswer, setShowFlashcardAnswer] = useState(false);

  // Audio Metering State
  const [audioMetering, setAudioMetering] = useState(Array(50).fill(0)); // Holds last N levels

  // FAB State
  const [isFabExpanded, setIsFabExpanded] = useState(false);
  const fadeAnim = useRef(new Animated.Value(0)).current;

  // Recording Timer State
  const [recordingDuration, setRecordingDuration] = useState(0);
  const recordingTimerRef = useRef(null);

  const DEEPGRAM_API_KEY = Constants.expoConfig?.extra?.deepgramApiKey;
  const OPENROUTER_API_KEY = Constants.expoConfig?.extra?.openrouterApiKey;

  useEffect(() => {
    loadSavedLectures();
  }, []);

  // FAB Animation
  useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: isFabExpanded ? 1 : 0,
      duration: 200,
      useNativeDriver: true,
      easing: Easing.ease,
    }).start();
  }, [isFabExpanded]);

  // Recording Timer
  useEffect(() => {
    if (isRecording) {
      recordingTimerRef.current = setInterval(() => {
        setRecordingDuration(prev => prev + 1);
      }, 1000);
    } else {
      clearInterval(recordingTimerRef.current);
    }
    return () => clearInterval(recordingTimerRef.current);
  }, [isRecording]);

  const formatFullTimer = (seconds) => {
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // --- Auto-Save Logic ---
  const saveOrUpdateLecture = async (updates) => {
    try {
      const lectureId = currentLectureId || Date.now().toString();
      if (!currentLectureId) setCurrentLectureId(lectureId);

      const lecturesJson = await AsyncStorage.getItem('lectures');
      const latestLectures = lecturesJson ? JSON.parse(lecturesJson) : [];

      const existingLectureIndex = latestLectures.findIndex(l => l.id === lectureId);
      const existingLecture = existingLectureIndex >= 0 ? latestLectures[existingLectureIndex] : {};

      const lectureData = {
        ...existingLecture,
        id: lectureId,
        timestamp: existingLecture.timestamp || new Date().toISOString(),
        audioUri: updates.audioUri !== undefined ? updates.audioUri : (existingLecture.audioUri || audioUri),
        transcribedText: updates.transcribedText !== undefined ? updates.transcribedText : (existingLecture.transcribedText || transcribedText),
        transcriptSegments: updates.transcriptSegments !== undefined ? updates.transcriptSegments : (existingLecture.transcriptSegments || transcriptSegments),
        summary: updates.summary !== undefined ? updates.summary : (existingLecture.summary || summary),
        flashcards: updates.flashcards !== undefined ? updates.flashcards : (existingLecture.flashcards || flashcards),
        title: updates.title || existingLecture.title || 'New Lecture',
        durationStr: updates.durationStr || existingLecture.durationStr || '0min'
      };

      if (lectureData.title === 'New Lecture' && lectureData.transcribedText) {
        lectureData.title = lectureData.transcribedText.substring(0, 40) + '...';
      }

      const updatedLectures = [...latestLectures];
      if (existingLectureIndex >= 0) {
        updatedLectures[existingLectureIndex] = lectureData;
      } else {
        updatedLectures.unshift(lectureData);
      }

      setSavedLectures(updatedLectures);
      await AsyncStorage.setItem('lectures', JSON.stringify(updatedLectures));
      return lectureId;
    } catch (error) {
      console.error('Auto-save error:', error);
    }
  };

  const persistAudioFile = async (tempUri) => {
    try {
      const filename = `audio_${Date.now()}.wav`;
      const permUri = `${FileSystem.documentDirectory}${filename}`;
      await FileSystem.copyAsync({ from: tempUri, to: permUri });
      return permUri;
    } catch (error) {
      console.error('Persist audio error:', error);
      return tempUri;
    }
  };

  const loadSavedLectures = async () => {
    try {
      const lecturesJson = await AsyncStorage.getItem('lectures');
      if (lecturesJson) setSavedLectures(JSON.parse(lecturesJson));
    } catch (error) { console.error(error); }
  };

  const openLecture = (lecture) => {
    setCurrentLectureId(lecture.id);
    setAudioUri(lecture.audioUri);
    setTranscribedText(lecture.transcribedText || '');
    setTranscriptSegments(lecture.transcriptSegments || []);
    setSummary(lecture.summary || '');
    setFlashcards(lecture.flashcards || []);
    setCurrentScreen('details');
  };

  const goBackHome = async () => {
    if (player) {
      await player.stopAsync();
      await player.unloadAsync();
      setPlayer(null);
      setIsPlaying(false);
    }
    setCurrentScreen('home');
    setAudioUri(null);
    setTranscribedText('');
    setTranscriptSegments([]);
    setSummary('');
    setFlashcards([]);
    setCurrentLectureId(null);
    setProcessingStatus('');
    setIsProcessing(false);
    setRecordingDuration(0);
    setIsFabExpanded(false);
    setAudioMetering(Array(50).fill(0));
  };

  // --- Recording & Processing ---

  const prepareRecording = () => {
    setIsFabExpanded(false);
    setCurrentScreen('recording');
    setRecordingDuration(0);
    setAudioMetering(Array(50).fill(0));
  };

  const startRecording = async () => {
    try {
      const permission = await Audio.requestPermissionsAsync();
      if (!permission.granted) {
        Alert.alert('Permission required', 'Please grant microphone permission');
        return;
      }

      await Audio.setAudioModeAsync({
        allowsRecordingIOS: true,
        playsInSilentModeIOS: true
      });

      const { recording: newRecording } = await Audio.Recording.createAsync(
        Audio.RecordingOptionsPresets.HIGH_QUALITY,
        (status) => {
          if (status.isRecording && status.metering !== undefined) {
            // Normalize dB (-160 to 0) to 0-1 range approx for visualization
            const db = status.metering;
            const normalized = Math.min(Math.max((db + 60) / 60, 0), 1); // Only showing top 60dB

            // Shift array
            setAudioMetering(prev => {
              const newArr = [...prev.slice(1), normalized];
              return newArr;
            });
          }
        },
        100 // Update every 100ms
      );

      setRecording(newRecording);
      setIsRecording(true);
    } catch (err) { Alert.alert('Error', 'Failed to start recording'); }
  };

  const stopRecording = async () => {
    if (!recording) return;
    setIsRecording(false);
    setProcessingStatus('Processing audio...');
    setIsProcessing(true);
    setCurrentScreen('details');

    try {
      await recording.stopAndUnloadAsync();
      const tempUri = recording.getURI();
      const permUri = await persistAudioFile(tempUri);
      setAudioUri(permUri);
      setRecording(null);

      const durationMins = Math.ceil(recordingDuration / 60);
      const id = await saveOrUpdateLecture({ audioUri: permUri, title: 'New Recording...', durationStr: `${durationMins}min` });
      setCurrentLectureId(id);

      await processAudio(permUri, id);
    } catch (err) {
      console.error(err);
      setProcessingStatus('Error processing recording');
      setIsProcessing(false);
    }
  };

  const handleUpload = async () => {
    setIsFabExpanded(false);
    try {
      const result = await DocumentPicker.getDocumentAsync({ type: 'audio/*' });
      if (result.type === 'success' || !result.canceled) {
        const tempUri = result.assets ? result.assets[0].uri : result.uri;
        const name = result.assets ? result.assets[0].name : 'Uploaded Audio';

        const permUri = await persistAudioFile(tempUri);
        setAudioUri(permUri);
        setCurrentScreen('details');
        setProcessingStatus('Uploading & Processing...');
        setIsProcessing(true);

        const id = await saveOrUpdateLecture({ audioUri: permUri, title: name });
        setCurrentLectureId(id);

        await processAudio(permUri, id);
      }
    } catch (err) { Alert.alert('Error', 'Upload failed'); }
  };

  const processAudio = async (uri, lectureId) => {
    try {
      if (!DEEPGRAM_API_KEY) throw new Error('Deepgram API key missing');

      setProcessingStatus('Transcribing...');
      const audioBase64 = await FileSystem.readAsStringAsync(uri, { encoding: 'base64' });
      const binaryString = atob(audioBase64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);

      const response = await fetch('https://api.deepgram.com/v1/listen?punctuate=true&utterances=true', {
        method: 'POST',
        headers: { 'Authorization': `Token ${DEEPGRAM_API_KEY}`, 'Content-Type': 'audio/wav' },
        body: bytes,
      });

      const data = await response.json();

      if (data.results?.channels?.[0]?.alternatives?.[0]?.transcript) {
        const text = data.results.channels[0].alternatives[0].transcript;
        setTranscribedText(text);

        let segments = [];
        if (data.results?.utterances) {
          segments = data.results.utterances.map(u => ({ text: u.transcript, start: u.start, end: u.end }));
        } else {
          segments = [{ text, start: 0, end: 0 }];
        }
        setTranscriptSegments(segments);

        await saveOrUpdateLecture({ transcribedText: text, transcriptSegments: segments, title: text.slice(0, 50) });

        setProcessingStatus('Generating summary...');
        await generateSummary(text);

        setProcessingStatus('Creating flashcards...');
        await generateFlashcards(text);

        setProcessingStatus('');
        setIsProcessing(false);
      } else {
        throw new Error('No transcription generated');
      }
    } catch (err) {
      console.error(err);
      setProcessingStatus('Failed: ' + err.message);
      setIsProcessing(false);
    }
  };

  const generateSummary = async (text) => {
    if (!OPENROUTER_API_KEY) return;
    try {
      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${OPENROUTER_API_KEY}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'meta-llama/llama-3.2-3b-instruct:free',
          messages: [{ role: 'user', content: `Summarize this transcript in bullet points:\n\n${text}` }],
        }),
      });
      const data = await response.json();
      const summaryText = data.choices?.[0]?.message?.content;
      if (summaryText) {
        setSummary(summaryText);
        await saveOrUpdateLecture({ summary: summaryText });
      }
    } catch (e) { console.error(e); }
  };

  const generateFlashcards = async (text) => {
    if (!OPENROUTER_API_KEY) return;
    try {
      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${OPENROUTER_API_KEY}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'meta-llama/llama-3.2-3b-instruct:free',
          messages: [{ role: 'user', content: `Generate 5 flashcards (JSON format: [{"question": "...", "answer": "..."}]) based on:\n\n${text}` }],
        }),
      });
      const data = await response.json();
      if (data.choices?.[0]?.message?.content) {
        let content = data.choices[0].message.content;
        content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const start = content.indexOf('[');
        const end = content.lastIndexOf(']');
        if (start !== -1 && end !== -1) {
          content = content.substring(start, end + 1);
          const cards = JSON.parse(content);
          if (Array.isArray(cards)) {
            setFlashcards(cards);
            await saveOrUpdateLecture({ flashcards: cards });
          }
        }
      }
    } catch (e) { console.error(e); }
  };

  // --- Audio Player Logic ---
  useEffect(() => {
    return () => {
      if (player) player.unloadAsync();
    };
  }, [player]);

  const togglePlayback = async () => {
    try {
      if (player) {
        if (isPlaying) { await player.pauseAsync(); setIsPlaying(false); }
        else { await player.playAsync(); setIsPlaying(true); }
      } else if (audioUri) {
        const { sound } = await Audio.Sound.createAsync({ uri: audioUri }, { shouldPlay: true });
        setPlayer(sound);
        setIsPlaying(true);
        sound.setOnPlaybackStatusUpdate(status => {
          if (status.isLoaded) {
            setPlaybackPosition(status.positionMillis);
            setPlaybackDuration(status.durationMillis);
            if (status.didJustFinish) { setIsPlaying(false); setPlaybackPosition(0); }
          }
        });
      }
    } catch (e) { console.error('Playback error', e); Alert.alert('Error', 'Could not play audio'); }
  };

  const seekToTimestamp = async (seconds) => {
    try {
      if (player) {
        await player.setPositionAsync(seconds * 1000);
        if (!isPlaying) { await player.playAsync(); setIsPlaying(true); }
      } else if (audioUri) {
        const { sound } = await Audio.Sound.createAsync({ uri: audioUri }, { shouldPlay: true, positionMillis: seconds * 1000 });
        setPlayer(sound);
        setIsPlaying(true);
        sound.setOnPlaybackStatusUpdate(status => {
          if (status.isLoaded) {
            setPlaybackPosition(status.positionMillis);
            setPlaybackDuration(status.durationMillis);
            if (status.didJustFinish) { setIsPlaying(false); setPlaybackPosition(0); }
          }
        });
      }
    } catch (e) { console.error('Seek error', e); }
  };

  const handleAskAI = async () => {
    if (!aiPrompt.trim() || !OPENROUTER_API_KEY) return;
    try {
      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${OPENROUTER_API_KEY}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'meta-llama/llama-3.2-3b-instruct:free',
          messages: [
            { role: 'system', content: `Context:\n${transcribedText}` },
            { role: 'user', content: aiPrompt }
          ]
        }),
      });
      const data = await response.json();
      const ans = data.choices?.[0]?.message?.content;
      if (ans) Alert.alert('AI Response', ans);
      setAiPrompt('');
    } catch (e) { Alert.alert('Error', 'AI failed'); }
  };

  // --- RENDERERS ---

  const renderHome = () => {
    // Apply LayoutAnimation when list changes
    useEffect(() => {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    }, [savedLectures, searchQuery]);

    const filteredLectures = savedLectures.filter(l => l.title?.toLowerCase().includes(searchQuery.toLowerCase()));

    return (
      <SafeAreaView style={styles.container}>
        <StatusBar barStyle="dark-content" />

        {/* Header */}
        <View style={styles.header}>
          <View style={styles.brandContainer}>
            <Image source={require('./assets/logo_black.png')} style={styles.logoImage} />
            <Text style={styles.headerTitle}>Memry</Text>
          </View>
          <ScalePress onPress={() => setActiveTab('profile')}>
            <View style={styles.profileAvatar}>
              <Text style={styles.profileInitials}>o</Text>
            </View>
          </ScalePress>
        </View>

        {/* Search */}
        <View style={styles.searchWrapper}>
          <View style={styles.searchContainer}>
            <Ionicons name="search" size={16} color="#000" style={{ marginRight: 8 }} />
            <TextInput
              style={styles.searchInput}
              placeholder="Search"
              placeholderTextColor="#000"
              value={searchQuery}
              onChangeText={setSearchQuery}
            />
          </View>
        </View>

        {/* Filters */}
        <View style={styles.filterWrapper}>
          <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.filterContent}>
            <ScalePress style={[styles.filterChip, styles.filterChipActive]} onPress={() => { }}>
              <Text style={[styles.filterText, styles.filterTextActive]}>All</Text>
            </ScalePress>

            <ScalePress style={styles.filterChip} onPress={() => { }}>
              <Ionicons name="star" size={14} color="#4d4d4d" style={{ marginRight: 4 }} />
              <Text style={styles.filterText}>Favorites</Text>
            </ScalePress>

            <ScalePress style={styles.filterChip} onPress={() => { }}>
              <MaterialCommunityIcons name="atom" size={16} color="#4d4d4d" style={{ marginRight: 4 }} />
              <Text style={styles.filterText}>Physics</Text>
            </ScalePress>

            <ScalePress style={styles.addFilterChip} onPress={() => { }}>
              <Ionicons name="add" size={16} color="#666" style={{ opacity: 0.5 }} />
            </ScalePress>
          </ScrollView>
        </View>

        {/* List */}
        <FlatList
          data={filteredLectures}
          keyExtractor={item => item.id}
          contentContainerStyle={styles.listContent}
          showsVerticalScrollIndicator={false}
          renderItem={({ item, index }) => (
            <ScalePress style={styles.lectureCard} onPress={() => openLecture(item)} activeScale={0.98}>
              <View style={styles.cardHeader}>
                <Text style={styles.cardTitle} numberOfLines={1}>{item.title || 'Untitled Lecture'}</Text>
                <TouchableOpacity>
                  <Ionicons name="ellipsis-horizontal" size={20} color="#8E8E93" />
                </TouchableOpacity>
              </View>

              <View style={styles.cardMetaRow}>
                <View style={styles.metaItem}>
                  <Ionicons name="calendar-clear-outline" size={12} color="#868686" style={{ marginRight: 4 }} />
                  <Text style={styles.cardMetaText}>{formatDate(item.timestamp)}</Text>
                </View>
                <View style={styles.metaItem}>
                  <MaterialIcons name="graphic-eq" size={12} color="#868686" style={{ marginRight: 4 }} />
                  <Text style={styles.cardMetaText}>{item.durationStr || '15min'}</Text>
                </View>
              </View>

              <View style={styles.cardFooter}>
                <View style={styles.cardIcons}>
                  <View style={styles.iconBadge}>
                    <Ionicons name="document-text-outline" size={14} color="#666" />
                  </View>
                  <View style={[styles.iconBadge, { marginLeft: -8, backgroundColor: '#f7f7f7' }]}>
                    <MaterialCommunityIcons name="chip" size={14} color="#666" />
                  </View>
                </View>
                <TouchableOpacity>
                  <Ionicons name="star" size={18} color="#e5e5e5" />
                </TouchableOpacity>
              </View>
            </ScalePress>
          )}
          ListEmptyComponent={
            <View style={{ alignItems: 'center', marginTop: 50 }}>
              <Text style={styles.placeholderText}>No lectures found</Text>
            </View>
          }
        />

        {/* FAB */}
        <View style={styles.fabWrapper}>
          {isFabExpanded && (
            <Animated.View style={[styles.fabMenuContainer, { opacity: fadeAnim }]}>
              <ScalePress style={styles.fabMenuItem} onPress={handleUpload}>
                <Text style={styles.fabMenuText}>Files</Text>
                <Ionicons name="document-attach-outline" size={20} color="#FFF" />
              </ScalePress>
              <ScalePress style={styles.fabMenuItem} onPress={prepareRecording}>
                <Text style={styles.fabMenuText}>Record</Text>
                <Ionicons name="mic-outline" size={20} color="#FFF" />
              </ScalePress>
            </Animated.View>
          )}

          <ScalePress
            style={styles.fab}
            onPress={() => setIsFabExpanded(!isFabExpanded)}
          >
            <Ionicons name={isFabExpanded ? "close" : "add"} size={32} color="#fff" />
          </ScalePress>
        </View>
      </SafeAreaView>
    );
  };

  const renderRecording = () => (
    <SafeAreaView style={styles.container}>
      <View style={styles.recordingHeader}>
        {/* Intentionally empty for clean look */}
      </View>

      <View style={styles.recordingBody}>
        {/* Timer */}
        <Text style={styles.recordingTimer}>{formatFullTimer(recordingDuration)}</Text>

        {/* Waveform Visualizer */}
        <View style={styles.waveformContainer}>
          {audioMetering.map((level, i) => (
            <WaveBar key={i} level={level} index={i} isRecording={isRecording} />
          ))}
        </View>
      </View>

      {/* Controls */}
      <View style={styles.recordingControls}>
        {!isRecording && recordingDuration === 0 ? (
          <TouchableOpacity style={styles.recordButton} onPress={startRecording}>
            <View style={styles.recordButtonInner} />
          </TouchableOpacity>
        ) : (
          <View style={styles.activeControls}>
            {/* Left Column: Pause */}
            <View style={[styles.controlColumn, { alignItems: 'flex-end', paddingRight: 20 }]}>
              <TouchableOpacity style={styles.pauseButton} onPress={() => { /* Pause logic implementation future */ }}>
                <Ionicons name="pause" size={24} color="#666" />
              </TouchableOpacity>
            </View>

            {/* Center Column: Stop */}
            <View style={styles.controlColumnCenter}>
              <TouchableOpacity style={styles.recordButton} onPress={stopRecording}>
                <View style={styles.stopButtonSquare} />
              </TouchableOpacity>
            </View>

            {/* Right Column: Placeholder/Space */}
            <View style={[styles.controlColumn, { alignItems: 'flex-start', paddingLeft: 20 }]} />
          </View>
        )}
      </View>

      {!isRecording && recordingDuration === 0 && (
        <TouchableOpacity style={styles.cancelRecording} onPress={goBackHome}>
          <Ionicons name="close-circle" size={40} color="#ddd" />
        </TouchableOpacity>
      )}
    </SafeAreaView>
  );

  const renderDetails = () => (
    <SafeAreaView style={styles.container}>
      <View style={styles.detailHeader}>
        <TouchableOpacity onPress={goBackHome} style={styles.backButton}>
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.detailTitle} numberOfLines={1}>
          {savedLectures.find(l => l.id === currentLectureId)?.title || 'Lecture'}
        </Text>
        <View style={{ width: 24 }} />
      </View>

      {isProcessing && (
        <View style={styles.processingBanner}>
          <ActivityIndicator size="small" color="#000" />
          <Text style={styles.processingBannerText}>{processingStatus}</Text>
        </View>
      )}

      {/* Audio Player - Minimalist */}
      <View style={styles.playerContainer}>
        <TouchableOpacity onPress={togglePlayback} style={styles.playPauseBtn}>
          <Ionicons name={isPlaying ? "pause" : "play"} size={22} color="#fff" />
        </TouchableOpacity>
        <View style={styles.sliderContainer}>
          <View style={[styles.progressFill, { width: `${(playbackDuration > 0 ? (playbackPosition / playbackDuration) * 100 : 0)}%` }]} />
        </View>
        <Text style={styles.timeText}>
          {Math.floor(playbackPosition / 1000 / 60)}:{String(Math.floor(playbackPosition / 1000 % 60)).padStart(2, '0')}
        </Text>
      </View>

      {/* Tabs */}
      <View style={styles.tabBar}>
        {['transcript', 'summary', 'materials'].map(tab => (
          <TouchableOpacity key={tab} style={[styles.tabItem, activeTab === tab && styles.tabItemActive]} onPress={() => setActiveTab(tab)}>
            <Text style={[styles.tabText, activeTab === tab && styles.tabTextActive]}>
              {tab.charAt(0).toUpperCase() + tab.slice(1)}
            </Text>
          </TouchableOpacity>
        ))}
      </View>

      <ScrollView style={styles.detailContent}>
        {activeTab === 'transcript' && (
          <View>
            {transcriptSegments.length > 0 ? transcriptSegments.map((seg, i) => (
              <TouchableOpacity key={i} style={styles.transcriptBlock} onPress={() => seekToTimestamp(seg.start)}>
                <Text style={styles.transcriptTime}>
                  {Math.floor(seg.start / 60)}:{String(Math.floor(seg.start % 60)).padStart(2, '0')}
                </Text>
                <Text style={styles.transcriptBody}>{seg.text}</Text>
              </TouchableOpacity>
            )) : <Text style={styles.placeholderText}>{isProcessing ? "Transcribing..." : "No transcript available"}</Text>}
          </View>
        )}

        {activeTab === 'summary' && (
          <Text style={styles.contentBody}>{summary || (isProcessing ? "Generating summary..." : "No summary available")}</Text>
        )}

        {activeTab === 'materials' && (
          <View>
            <View style={styles.materialsSubTabs}>
              <TouchableOpacity onPress={() => setMaterialsSubTab('flashcards')} style={[styles.subTab, materialsSubTab === 'flashcards' && styles.subTabActive]}>
                <Text style={[styles.subTabText, materialsSubTab === 'flashcards' && styles.subTabTextActive]}>Flashcards</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => setMaterialsSubTab('notes')} style={[styles.subTab, materialsSubTab === 'notes' && styles.subTabActive]}>
                <Text style={[styles.subTabText, materialsSubTab === 'notes' && styles.subTabTextActive]}>Notes</Text>
              </TouchableOpacity>
            </View>

            {materialsSubTab === 'flashcards' && (
              <View style={styles.flashcardContainer}>
                {flashcards.length > 0 ? (
                  <View style={styles.flashcardWrapper}>
                    <TouchableOpacity style={styles.flashcard} onPress={() => setShowFlashcardAnswer(!showFlashcardAnswer)}>
                      <Text style={styles.flashcardContent}>
                        {showFlashcardAnswer ? flashcards[currentFlashcardIndex].answer : flashcards[currentFlashcardIndex].question}
                      </Text>
                      <Text style={styles.flashcardFlipHint}>Tap to flip</Text>
                    </TouchableOpacity>
                    <View style={styles.flashcardNav}>
                      <TouchableOpacity disabled={currentFlashcardIndex === 0} onPress={() => { setCurrentFlashcardIndex(c => c - 1); setShowFlashcardAnswer(false); }}>
                        <Ionicons name="chevron-back" size={30} color={currentFlashcardIndex === 0 ? "#eee" : "#000"} />
                      </TouchableOpacity>
                      <Text style={styles.fcCounter}>{currentFlashcardIndex + 1}/{flashcards.length}</Text>
                      <TouchableOpacity disabled={currentFlashcardIndex === flashcards.length - 1} onPress={() => { setCurrentFlashcardIndex(c => c + 1); setShowFlashcardAnswer(false); }}>
                        <Ionicons name="chevron-forward" size={30} color={currentFlashcardIndex === flashcards.length - 1 ? "#eee" : "#000"} />
                      </TouchableOpacity>
                    </View>
                  </View>
                ) : (
                  <Text style={styles.placeholderText}>{isProcessing ? "Generating..." : "No flashcards"}</Text>
                )}
              </View>
            )}

            {materialsSubTab === 'notes' && <Text style={styles.placeholderText}>Notes coming soon</Text>}
          </View>
        )}
      </ScrollView>

      {/* Ask AI */}
      <View style={styles.askAiContainer}>
        <TextInput
          style={styles.askAiInput}
          placeholder="Ask AI..."
          value={aiPrompt}
          onChangeText={setAiPrompt}
          onSubmitEditing={handleAskAI}
        />
        <TouchableOpacity onPress={handleAskAI} style={styles.askAiBtn}>
          <Ionicons name="arrow-up" size={20} color="#fff" />
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );

  return (
    <View style={{ flex: 1, backgroundColor: '#f5f5f5' }}>
      {currentScreen === 'home' && renderHome()}
      {currentScreen === 'recording' && renderRecording()}
      {currentScreen === 'details' && renderDetails()}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: COLORS.background }, // Removed status bar height padding as SafeAreaView handles it mostly, but can adjust if needed.

  // Header
  // Top: 82px in CSS is relative, but usually implies safe area + spacing.
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingTop: 10,
    paddingBottom: 10,
    marginTop: Platform.OS === 'android' ? 30 : 0
  },
  brandContainer: { flexDirection: 'row', alignItems: 'center', gap: 2 },
  logoImage: { width: 33, height: 31, resizeMode: 'contain', marginRight: 0 },
  headerTitle: { fontSize: 16, fontWeight: '600', color: COLORS.textPrimary, fontFamily: Platform.OS === 'ios' ? 'System' : 'Roboto' },
  profileAvatar: {
    width: 30,
    height: 30,
    borderRadius: 40,
    backgroundColor: COLORS.activeFilter,
    justifyContent: 'center',
    alignItems: 'center'
  },
  profileInitials: { color: COLORS.white, fontWeight: '500', fontSize: 16, lineHeight: 20 },

  // Search
  searchWrapper: { paddingHorizontal: 16, marginBottom: 16, marginTop: 10 },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.searchBg,
    borderRadius: 16,
    height: 46,
    paddingHorizontal: 16
  },
  searchInput: {
    flex: 1,
    marginLeft: 4,
    fontSize: 14,
    color: COLORS.textPrimary,
    fontWeight: '400',
    height: '100%'
  },

  // Filters
  filterWrapper: { marginBottom: 15, height: 38 },
  filterContent: { paddingHorizontal: 16, alignItems: 'center', gap: 8 },
  filterChip: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.searchBg,
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 12,
    height: 35,
    borderWidth: 0.5,
    borderColor: COLORS.filterBorder,
    marginRight: 8
  },
  filterChipActive: { backgroundColor: COLORS.activeFilter, borderWidth: 0, borderColor: COLORS.activeFilter },
  filterText: { fontSize: 13, color: '#4d4d4d', fontWeight: '500' },
  filterTextActive: { color: COLORS.white },
  addFilterChip: {
    width: 28,
    height: 28,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(228, 228, 228, 0.5)',
    borderRadius: 14,
    borderWidth: 0.5,
    borderColor: '#e5e5e5'
  },

  // List
  listContent: { paddingHorizontal: 16, paddingBottom: 100 },
  lectureCard: {
    backgroundColor: COLORS.white,
    borderRadius: 14,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: COLORS.border,
    // Box Shadow replication
    shadowColor: '#dadada',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.4,
    shadowRadius: 10,
    elevation: 2
  },
  cardHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: 8 },
  cardTitle: {
    fontSize: 14,
    fontWeight: '500',
    color: COLORS.textPrimary,
    flex: 1,
    marginRight: 10,
    lineHeight: 20
  },
  cardMetaRow: { flexDirection: 'row', alignItems: 'center', marginBottom: 20 },
  metaItem: { flexDirection: 'row', alignItems: 'center', marginRight: 16 },
  cardMetaText: { fontSize: 12, color: COLORS.textSecondary, fontWeight: '400' },

  cardFooter: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' },
  cardIcons: { flexDirection: 'row', alignItems: 'center' },
  iconBadge: {
    width: 20,
    height: 20,
    borderRadius: 5,
    backgroundColor: '#f7f7f7', // from css ellipsis-3-2
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: -4
  },

  // FAB
  fabWrapper: { position: 'absolute', bottom: 30, right: 30, alignItems: 'center' },
  fab: {
    width: 66,
    height: 66,
    borderRadius: 33,
    backgroundColor: COLORS.fab,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 4.65,
    elevation: 8,
  },
  fabMenuContainer: { position: 'absolute', bottom: 80, right: 0, alignItems: 'flex-end', gap: 10 },
  fabMenuItem: { backgroundColor: '#212121', paddingHorizontal: 16, paddingVertical: 10, borderRadius: 20, flexDirection: 'row', alignItems: 'center', gap: 8, marginBottom: 8, shadowColor: "#000", shadowOpacity: 0.2, shadowRadius: 3, elevation: 5 },
  fabMenuText: { color: '#FFF', fontWeight: '600' },

  // Other Existing Styles
  placeholderText: { textAlign: 'center', marginTop: 40, color: '#aaa' },


  // Recording Screen
  recordingHeader: { height: 60 },
  recordingBody: { flex: 1, justifyContent: 'center', alignItems: 'center', paddingBottom: 50 },
  recordingTimer: { fontSize: 64, fontWeight: '400', color: '#000', marginBottom: 60, fontVariant: ['tabular-nums'], letterSpacing: 2 },
  waveformContainer: { height: 60, flexDirection: 'row', alignItems: 'center', justifyContent: 'center', width: '100%' },
  // dottedLine removed

  recordingControls: { width: '100%', alignItems: 'center', marginBottom: 50 },
  activeControls: { flexDirection: 'row', alignItems: 'center', justifyContent: 'center', width: '100%' },
  controlColumn: { flex: 1, justifyContent: 'center' },
  controlColumnCenter: { width: 100, alignItems: 'center', justifyContent: 'center' },

  recordButton: { width: 72, height: 72, borderRadius: 36, backgroundColor: '#E0E0E0', alignItems: 'center', justifyContent: 'center' },
  recordButtonInner: { width: 24, height: 24, borderRadius: 12, backgroundColor: '#FF3B30' },
  stopButtonSquare: { width: 24, height: 24, borderRadius: 4, backgroundColor: '#FF3B30' },

  pauseButton: { width: 56, height: 56, borderRadius: 28, backgroundColor: '#E0E0E0', alignItems: 'center', justifyContent: 'center' },
  controlButton: { width: 50, height: 50, borderRadius: 25, backgroundColor: '#E0E0E0', alignItems: 'center', justifyContent: 'center' },

  cancelRecording: { position: 'absolute', bottom: 40, alignSelf: 'center' },

  // Details
  detailHeader: { flexDirection: 'row', alignItems: 'center', padding: 15, backgroundColor: '#fff', borderBottomWidth: 1, borderColor: '#f0f0f0' },
  backButton: { padding: 4 },
  detailTitle: { flex: 1, textAlign: 'center', fontSize: 16, fontWeight: '600' },
  processingBanner: { flexDirection: 'row', padding: 10, backgroundColor: '#E3F2FD', justifyContent: 'center' },
  processingBannerText: { marginLeft: 8, color: '#1976D2' },

  playerContainer: { flexDirection: 'row', alignItems: 'center', padding: 16, backgroundColor: '#fff', margin: 16, borderRadius: 12, shadowColor: '#000', shadowOpacity: 0.05, shadowRadius: 5 },
  playPauseBtn: { width: 36, height: 36, borderRadius: 18, backgroundColor: '#1C1C1E', justifyContent: 'center', alignItems: 'center', marginRight: 12 },
  sliderContainer: { flex: 1, height: 4, backgroundColor: '#eee', borderRadius: 2 },
  progressFill: { height: '100%', backgroundColor: '#1C1C1E', borderRadius: 2 },
  timeText: { marginLeft: 12, fontSize: 12, color: '#666' },

  tabBar: { flexDirection: 'row', backgroundColor: '#fff', paddingHorizontal: 16, borderBottomWidth: 1, borderColor: '#f0f0f0' },
  tabItem: { marginRight: 24, paddingVertical: 12 },
  tabItemActive: { borderBottomWidth: 2, borderColor: '#1C1C1E' },
  tabText: { fontSize: 14, color: '#999', fontWeight: '500' },
  tabTextActive: { color: '#1C1C1E' },

  detailContent: { flex: 1, backgroundColor: '#F2F2F2', padding: 16 },
  transcriptBlock: { marginBottom: 16, padding: 12, backgroundColor: '#fff', borderRadius: 8 },
  transcriptTime: { fontSize: 12, color: '#007AFF', marginBottom: 4 },
  transcriptBody: { fontSize: 15, lineHeight: 22, color: '#333' },
  contentBody: { fontSize: 15, lineHeight: 24, color: '#333' },
  placeholderText: { textAlign: 'center', marginTop: 40, color: '#999' },

  // Materials
  materialsSubTabs: { flexDirection: 'row', justifyContent: 'center', marginBottom: 20 },
  subTab: { paddingVertical: 6, paddingHorizontal: 16, borderRadius: 16, backgroundColor: '#e0e0e0', marginHorizontal: 4 },
  subTabActive: { backgroundColor: '#1C1C1E' },
  subTabText: { fontSize: 12, color: '#666' },
  subTabTextActive: { color: '#fff' },

  flashcardWrapper: { alignItems: 'center' },
  flashcard: { width: '100%', height: 200, backgroundColor: '#fff', borderRadius: 16, justifyContent: 'center', alignItems: 'center', padding: 20, shadowColor: '#000', shadowOpacity: 0.05, shadowRadius: 5 },
  flashcardContent: { fontSize: 18, textAlign: 'center', fontWeight: '500' },
  flashcardFlipHint: { position: 'absolute', bottom: 10, fontSize: 10, color: '#ccc' },
  flashcardNav: { flexDirection: 'row', alignItems: 'center', marginTop: 16, gap: 20 },
  fcCounter: { fontSize: 14, fontWeight: '600' },

  askAiContainer: { flexDirection: 'row', padding: 16, backgroundColor: '#fff', borderTopWidth: 1, borderColor: '#eee' },
  askAiInput: { flex: 1, backgroundColor: '#f5f5f5', borderRadius: 20, paddingHorizontal: 16, paddingVertical: 8, fontSize: 14 },
  askAiBtn: { width: 36, height: 36, borderRadius: 18, backgroundColor: '#1C1C1E', justifyContent: 'center', alignItems: 'center', marginLeft: 8 },
});